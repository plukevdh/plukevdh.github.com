---
layout: post
title: ! 'Read the Damn Code (RtDC) - Episode 1: Union vs. Array#uniq!'
published: true
date: 2011-03-28
categories: []
posterous_url: http://blog.hungerandthirstdesign.com/post/4163548174/read-the-damn-code-rtdc-episode-1-union-vs
posterous_slug: post/4163548174/read-the-damn-code-rtdc-episode-1-union-vs
---
<p>So as part of a quick request to modify our very meta-stats system, I got a first look at the code that runs the stats generation/reporting for our site&rsquo;s activities. Can I say again, its awesomely meta? (Props to <a href="http://twitter.com/tjsingleton" target="_blank">@tjsingleton</a>).</p>
<p>So basically we setup custom hashes that grab data from the DB that contain common stats that interest us and our customers, like how many emails got sent on a given day, how many presentations were given, how many invites were sent or accepted. Pretty easy stuff. The magic happens in translating it from the data into graph-interpretable data, which, again, is not too complicated. It just means formatting our hashes into something the graphing engine can read and render.</p>
<p>So my quick request was just to change the order of a few column headers in the stats reporting table. Easy? Well. So everything gets thrown into a single hash <strong>unless</strong> we&rsquo;re calculating the stats from previously gathered stats. For example, live presentations is the difference between total presentations and emailed presentations. Ruby lets you do simple Array1 - Array2 = (x: x &isin; Array1 and x &notin; Array2). Simple difference right? Cool. But these special calculated hashes are stored in a separate array, which I found out, are then combined via <code>Array#|</code> (union) later on. Which creates an order problem. Since union has no means of ordering elements, it just appends the additional elements onto the end of the returned array. Which is fine <strong>unless</strong> we want to keep the order in which we defined the keys (in say some <code>.rb</code> or <code>.yaml</code> definition file).</p>
<p>So what to do? Simple. Store the keys in their own array aside from the hashes the data is being appended onto and run <code>uniq!</code> when we request the value of the keys to ensure we get all unique values. A good idea?</p>
<p>I found out a few things about a better way (although someone else may have the &ldquo;best way&rdquo;) to do some of these things. First of all, don&rsquo;t do</p>
<p><code> keys &lt;&lt; key unless keys.include? key </code></p>
<p>Why? <code>include?</code> has to loop through the entire array to figure out if your element exists. The bigger your key array gets, the longer that takes. Return time for that hash will be incredibly fast though, as even uniq! is slower than simply returning an already unique array. I wanted to graph the tradeoff point that you should do this, but I figure the description alone is obvious enough.</p>
<p>Second, there&rsquo;s danger in keeping a key list separate from your actual data list. List syncing could be tricky to keep up with. Fortunately, this is an immutable list (for now). Once you load up the page, the stats are there to stay. This brings into question (why not use the <code>include?</code> code above if your list is small enough and you only load once? <strong>Webscale</strong> bitches.</p>
<p><code>uniq!</code> is really nice in that it converts the array to a hash to do the uniqueness check. This makes the data type handle the uniquifying aspect of making an array contain unique values. Brilliant? Yes. But digging deeper, how does this conversion work? Here&rsquo;s the code for <a href="http://www.ruby-doc.org/doxygen/1.8.4/array_8c-source.html#l02608" target="_blank">array.c</a>. It loops through each value of the array and adds it as a key to a disposable hash. Wait, looping each value again? How is this better? It&rsquo;s not so much about <em>that</em> it loops as it is <strong>when</strong> it loops. We run the <code>uniq!</code> only when the data is requested. This means a few things. 1) Once we <code>uniq!</code>, our array is updated and any further <code>uniq!</code> will have a smaller set of data to operate on. 2) We&rsquo;re running this when the data is requested, rather than on every add. Since we don&rsquo;t care about the data until we ask for it, we can save data-load operations by waiting until the last minute to ensure our data will show correctly.</p>
<p>Finally, what does the union do (<code>Array#|</code>)? Not surprisingly, pretty much the same thing as <code>uniq!</code> (<a href="http://www.ruby-doc.org/core/classes/Array.src/M000275.html" target="_blank">codez</a>). It creates a disposable hash from the array, and then tries to add any non-existing keys to the hash, using the hash as the uniqueness enforcer. The main difference is that union has to do this twice for the two arrays it is union-ing. Plus it creates a lot of other arrays in memory to hold the intermediate results. The main problem with using union in my case is that it appends new elements to the end, rather than giving us a way to keep order between two arrays, which is what we needed in the first place.</p>
<p>So, there you go. The answer is always in the code. Not a necessary look at the details, but one inspired to understand how a language works and how can we work faster.</p>
<p>A few&nbsp;nearly useless <a href="https://gist.github.com/890996" target="_blank">benchm</a><a href="https://gist.github.com/890996" target="_blank">arks</a> too!</p>
<p><script src="https://gist.github.com/890996.js"></script></p>
<p>TL;DR</p>
<p>Do your homework. Read the code. Think about the maths (and the Matz). It&rsquo;s always worth it, if not in performance, then in understanding.</p>
